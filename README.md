# Rescript Fields

Elaborate form validation for Rescript 

Fields is a module for managing the update and validation of complex input.
The singular `module type Field.T` describes the requirements for
creating, modifying and validating an input to produce either an output value or an error.
Using Rescript "Module Functors" Fields can be built that compose other Fields (producing a tree of Fields)
allowing validation and change reduction at each level. 
An attempt was made to implement common Fields and Field Patterns, and those are a large body of the library.
see FieldArray or FieldProduct.  
Each field is represented by a Field module that declares the storage, validation, and update of a value type.

## Installation

* Add `@nobleai/rescript-fields` to your project as you like
* Add `@nobleai/rescript-fields` to `bs-dev-dependencies`in bsconfig.json
* build `-with-deps`

## Provided Fields
* FieldIdentity
* FieldParse
* FieldArray 
* FieldSum (FieldEither)
* FieldProduct (FieldVector)
* FieldOpt

## Live example

For a runnable eversion try `yarn install; yarn rescript build; yarn run examples:everything`

## Login Form Example

```{rescript}

// The Username field is a string, that is validated with every change
module FieldUsername = FieldParse.String

// Password the same as username
module FieldPassword = FieldParse.String

// We want to combine username and password into a "Login" that is itself validated when both fields are valid.
// This type of composition is often called a "Product" from type theory, but specifically this is a collection of named subfields.
// First declare a structure for the product that gives names for each of the subfields of the login, but leaves the values as type parameters
// So this structure can be used in a few ways internally.
// This also uses deriving(accessors) which is convenient for client code, but also helpful for implementing some of the mapping below.
// This is outside of Generic to make accessors more easily available
@deriving(accessors)
type structure<'a, 'b> = {
  username: 'a,
  password: 'b,
}

// Give fields a map from your output type to a generic container (tuple)
// A "Generic" module is required by FieldProduct to translate between your particular named structure and the general Nested-Tuple in FieldVector.
// These are pretty reliably generated by Copilot btw.
module Generic = {
  type structure<'a, 'b> = structure<'a, 'b>

	// Order uses the accessors from above and orders them so we can know how the named fields are put into the vector.
  let order = (username, password)
	// FromTuple is the reverse, lifting a tuple of our sub-values into a structure.
  let fromTuple = ((username, password)) => {username, password}
}

// Finally combine the two children as a Product2 using the Generic module and the two sub fields.
module Field = FieldProduct.Product2.Make(
  Generic,
  FieldUsername,
  FieldPassword,
)
```


## TODO 
- debounced asyc validation  
- graphql async validation based on hook provided function  
- optimistic update chaging form twice?  
- Realign Polyvariant #A, #B, etc with sum 'a, 'b etc.


